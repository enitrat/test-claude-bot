name: claude-review

# Triggered by: @claude mention in PR comments (e.g., "@claude review this function")
#
# How prompt extraction works:
# The action's `extractUserRequest` function automatically extracts text AFTER "@claude".
# Example: "@claude review auth" → "review auth"
#
# See: https://github.com/anthropics/claude-code-action/blob/main/src/utils/extract-user-request.ts
#
# Security: Only users with write/admin permissions can trigger Claude.
# External contributors (fork PRs) are automatically blocked by the action.
# See: https://github.com/anthropics/claude-code-action/blob/main/src/github/validation/permissions.ts
#
# Secrets required:
# - CLAUDE_CODE_OAUTH_TOKEN: OAuth token from `claude setup-token`
# - CLAUDE_ACCESS_TOKEN: PAT with 'repo' scope for private repos
#
# Network sandbox:
# Claude Code runs behind a Squid proxy that only allows whitelisted domains.
# iptables rules enforce proxy-only egress (defense-in-depth against proxy bypass).
# See: https://github.com/zama-ai/security-hub/tree/main/docs/how-tos/sandboxed-claude-code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  pull_request:
    types: [opened, synchronize]

permissions: {}

jobs:
  claude-review:
    name: claude-review/respond
    if: |
      contains(github.event.comment.body, '@claude') &&
      (github.event.issue.pull_request || github.event_name == 'pull_request_review_comment')
    runs-on: ubuntu-latest
    permissions:
      contents: read # Required for checkout
      pull-requests: write # Required for PR review and comment actions
      issues: write # Required for issue comment actions
      id-token: write # Required for OIDC authentication
      actions: read # Required for reading CI results
    steps:
      # --- Phase 1: Setup (full network access) ---

      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false
          fetch-depth: 0

      - name: Install uv
        uses: astral-sh/setup-uv@61cb8a9741eeb8a550a1b8544337180c0fc8476b

      - name: Clone private repositories
        run: |
          gh repo clone enitrat/skill-issue /tmp/skill-issue
        env:
          GH_TOKEN: ${{ secrets.CLAUDE_ACCESS_TOKEN }}

      - name: Build custom system prompt
        id: custom_prompt
        run: |
          # Extract PR metadata from webhook payload
          if [[ "$EVENT_NAME" == "pull_request" ]] || [[ -n "$ISSUE_PR_URL" ]]; then
            # For pull_request events
            if [[ "$EVENT_NAME" == "pull_request" ]]; then
              PR_TITLE="$PR_TITLE_INPUT"
              PR_AUTHOR="$PR_AUTHOR_INPUT"
              PR_HEAD="$PR_HEAD_INPUT"
              PR_BASE="$PR_BASE_INPUT"
              PR_STATE="$PR_STATE_INPUT"
              PR_ADDITIONS="$PR_ADDITIONS_INPUT"
              PR_DELETIONS="$PR_DELETIONS_INPUT"
              PR_COMMITS="$PR_COMMITS_INPUT"
              PR_FILES="$PR_FILES_INPUT"
            else
              # For issue_comment on PRs - need to fetch PR data
              PR_NUMBER="$ISSUE_NUMBER_INPUT"
              PR_DATA=$(gh pr view "$PR_NUMBER" --json title,author,headRefName,baseRefName,state,additions,deletions,commits)
              PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
              PR_AUTHOR=$(echo "$PR_DATA" | jq -r '.author.login')
              PR_HEAD=$(echo "$PR_DATA" | jq -r '.headRefName')
              PR_BASE=$(echo "$PR_DATA" | jq -r '.baseRefName')
              PR_STATE=$(echo "$PR_DATA" | jq -r '.state')
              PR_ADDITIONS=$(echo "$PR_DATA" | jq -r '.additions')
              PR_DELETIONS=$(echo "$PR_DATA" | jq -r '.deletions')
              PR_COMMITS=$(echo "$PR_DATA" | jq -r '.commits | length')
              PR_FILES=$(gh pr view "$PR_NUMBER" --json files | jq '.files | length')
            fi

            # Build formatted context
            FORMATTED_CONTEXT="PR Title: ${PR_TITLE}
          PR Author: ${PR_AUTHOR}
          PR Branch: ${PR_HEAD} -> ${PR_BASE}
          PR State: ${PR_STATE^^}
          PR Additions: ${PR_ADDITIONS}
          PR Deletions: ${PR_DELETIONS}
          Total Commits: ${PR_COMMITS}
          Changed Files: ${PR_FILES} files"

            # Build system prompt
            SYSTEM_PROMPT="You are Claude, an AI assistant designed to help with GitHub issues and pull requests. Think carefully as you analyze the context and respond appropriately. Here's the context for your current task:

          <formatted_context>
          ${FORMATTED_CONTEXT}
          </formatted_context>"
          else
            # For issues
            ISSUE_TITLE="$ISSUE_TITLE_INPUT"
            ISSUE_AUTHOR="$ISSUE_AUTHOR_INPUT"
            ISSUE_STATE="$ISSUE_STATE_INPUT"

            FORMATTED_CONTEXT="Issue Title: ${ISSUE_TITLE}
          Issue Author: ${ISSUE_AUTHOR}
          Issue State: ${ISSUE_STATE^^}"

            SYSTEM_PROMPT="You are Claude, an AI assistant designed to help with GitHub issues and pull requests. Think carefully as you analyze the context and respond appropriately. Here's the context for your current task:

          <formatted_context>
          ${FORMATTED_CONTEXT}
          </formatted_context>"
          fi

          # Save to environment file for next step (using block redirect)
          {
            echo "CUSTOM_SYSTEM_PROMPT<<EOF"
            echo "$SYSTEM_PROMPT"
            echo "EOF"
          } >> "$GITHUB_ENV"
        env:
          GH_TOKEN: ${{ secrets.CLAUDE_ACCESS_TOKEN }}
          EVENT_NAME: ${{ github.event_name }}
          ISSUE_PR_URL: ${{ github.event.issue.pull_request.url || '' }}
          # Pull request event variables
          PR_TITLE_INPUT: ${{ github.event.pull_request.title }}
          PR_AUTHOR_INPUT: ${{ github.event.pull_request.user.login }}
          PR_HEAD_INPUT: ${{ github.event.pull_request.head.ref }}
          PR_BASE_INPUT: ${{ github.event.pull_request.base.ref }}
          PR_STATE_INPUT: ${{ github.event.pull_request.state }}
          PR_ADDITIONS_INPUT: ${{ github.event.pull_request.additions }}
          PR_DELETIONS_INPUT: ${{ github.event.pull_request.deletions }}
          PR_COMMITS_INPUT: ${{ github.event.pull_request.commits }}
          PR_FILES_INPUT: ${{ github.event.pull_request.changed_files }}
          # Issue event variables
          ISSUE_NUMBER_INPUT: ${{ github.event.issue.number }}
          ISSUE_TITLE_INPUT: ${{ github.event.issue.title }}
          ISSUE_AUTHOR_INPUT: ${{ github.event.issue.user.login }}
          ISSUE_STATE_INPUT: ${{ github.event.issue.state }}

      # --- Phase 2: Pre-exchange OIDC token (before network lockdown) ---
      # The action normally does OIDC → Anthropic exchange → GitHub App token internally,
      # but that uses fetch() which doesn't respect HTTP_PROXY and gets blocked by iptables.
      # By doing it here with curl (proxy-unaware, pre-lockdown), we get the token early
      # and pass it via `github_token` input to skip the action's internal OIDC flow.

      - name: Exchange OIDC for GitHub App token
        id: oidc-exchange
        run: |
          echo "::group::OIDC token exchange"

          # Step 1: Get OIDC JWT from GitHub Actions
          echo "Requesting OIDC token from GitHub..."
          OIDC_RESPONSE=$(curl -sf \
            -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=claude-code-github-action")
          OIDC_TOKEN=$(echo "$OIDC_RESPONSE" | jq -r '.value')

          if [ -z "$OIDC_TOKEN" ] || [ "$OIDC_TOKEN" = "null" ]; then
            echo "::error::Failed to get OIDC token from GitHub"
            echo "Response: $OIDC_RESPONSE"
            exit 1
          fi
          echo "Got OIDC token"

          # Step 2: Exchange OIDC token for GitHub App installation token via Anthropic
          echo "Exchanging OIDC token for GitHub App token..."
          EXCHANGE_RESPONSE=$(curl -sf -X POST \
            -H "Authorization: Bearer $OIDC_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"permissions":{"contents":"write","pull_requests":"write","issues":"write"}}' \
            "https://api.anthropic.com/api/github/github-app-token-exchange")
          APP_TOKEN=$(echo "$EXCHANGE_RESPONSE" | jq -r '.token')

          if [ -z "$APP_TOKEN" ] || [ "$APP_TOKEN" = "null" ]; then
            echo "::error::Failed to exchange OIDC token for GitHub App token"
            echo "Response: $EXCHANGE_RESPONSE"
            exit 1
          fi

          echo "::add-mask::$APP_TOKEN"
          echo "app_token=$APP_TOKEN" >> "$GITHUB_OUTPUT"
          echo "Got GitHub App token"
          echo "::endgroup::"

      # --- Phase 3: Pre-install all dependencies (before network lockdown) ---
      # The action internally runs setup-bun + bun install + claude install.
      # These use fetch()/HTTP clients that don't respect proxies and would be
      # blocked by iptables. Pre-install everything here, then pass paths to skip them.

      - name: Install Bun
        uses: oven-sh/setup-bun@3d267786b128fe76c2f16a390aa2448b815359f3
        with:
          bun-version: latest

      - name: Pre-install action dependencies
        id: setup-deps
        run: |
          ACTION_DIR="/home/runner/work/_actions/anthropics/claude-code-action/b433f16b30d54063fd3bab6b12f46f3da00e41b6"
          echo "Installing action dependencies in $ACTION_DIR..."
          cd "$ACTION_DIR" && bun install --production
          echo "bun_path=$(which bun)" >> "$GITHUB_OUTPUT"

      - name: Install Claude Code (npm)
        id: setup-claude
        run: |
          npm install -g @anthropic-ai/claude-code@2.1.42
          echo "path=$(which claude)" >> "$GITHUB_OUTPUT"

      # --- Phase 4: Network sandbox (lock down before running Claude) ---

      - name: Start Squid proxy for network sandbox
        run: |
          echo "::group::Starting Squid proxy with domain allowlist"

          # Start Squid proxy container with the allowlist config.
          # Port 3128 is exposed on localhost so the runner can reach it.
          # The proxy enforces domain-level allowlisting (Layer 7).
          docker run -d \
            --name sandbox-proxy \
            -p 3128:3128 \
            -v "${{ github.workspace }}/.github/squid/sandbox-proxy-rules.conf:/etc/squid/conf.d/00-sandbox-proxy-rules.conf:ro" \
            ubuntu/squid

          # Wait for Squid to be ready (up to 60s)
          # Use api.github.com (returns 200 without auth) instead of api.anthropic.com
          # (returns 401 without API key, which causes curl -f to fail).
          echo "Waiting for Squid proxy to become ready..."
          for i in $(seq 1 30); do
            if curl -sf -x http://localhost:3128 -o /dev/null https://api.github.com 2>/dev/null; then
              echo "Squid proxy is ready (attempt $i)"
              break
            fi
            if [ "$i" -eq 30 ]; then
              echo "::error::Squid proxy failed to start within 60s"
              docker logs sandbox-proxy
              exit 1
            fi
            sleep 2
          done

          echo "::endgroup::"

          # Verify: allowed domain works, blocked domain is rejected
          echo "::group::Verifying proxy allowlist"
          echo "Testing allowed domain (api.github.com)..."
          HTTP_CODE=$(curl -s -x http://localhost:3128 -o /dev/null -w '%{http_code}' https://api.github.com)
          echo "  status: $HTTP_CODE"
          if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 400 ]; then
            echo "::error::Allowed domain api.github.com returned $HTTP_CODE"
            exit 1
          fi

          echo "Testing blocked domain (google.com)..."
          if curl -sf -x http://localhost:3128 -o /dev/null https://google.com 2>/dev/null; then
            echo "::error::Blocked domain google.com was reachable through proxy!"
            exit 1
          fi
          echo "  Correctly blocked (expected)"
          echo "::endgroup::"

      - name: Lock down iptables (defense-in-depth)
        run: |
          echo "::group::Configuring iptables to force proxy-only egress"

          # Get the runner's UID to scope rules (only block the runner user)
          RUNNER_UID=$(id -u)
          echo "Runner UID: $RUNNER_UID"

          # Allow established connections (don't break in-flight traffic)
          sudo iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

          # Allow loopback (localhost proxy, Docker socket, etc.)
          sudo iptables -A OUTPUT -o lo -j ACCEPT

          # Allow traffic to Docker bridge (Squid proxy container)
          sudo iptables -A OUTPUT -d 172.16.0.0/12 -j ACCEPT

          # Block NEW outbound TCP from the runner user (force proxy use)
          # This only affects the runner UID — system services are unaffected.
          sudo iptables -A OUTPUT -m owner --uid-owner "$RUNNER_UID" \
            -p tcp --syn -j REJECT --reject-with tcp-reset

          echo "iptables rules applied for UID $RUNNER_UID"

          # Verify: direct connection is blocked
          echo "Verifying direct connection is blocked..."
          if curl -sf --max-time 5 -o /dev/null https://google.com 2>/dev/null; then
            echo "::error::Direct connection to google.com succeeded (should be blocked)!"
            exit 1
          fi
          echo "  Direct connection correctly blocked"

          # Verify: proxy connection still works
          echo "Verifying proxy connection still works..."
          if ! curl -sf --max-time 10 -x http://localhost:3128 -o /dev/null https://api.github.com 2>/dev/null; then
            echo "::error::Proxy connection to api.github.com failed!"
            exit 1
          fi
          echo "  Proxy connection works"

          echo "::endgroup::"

      # --- Phase 5: Run Claude Code (sandboxed) ---

      - name: Run Claude Code
        id: run-claude
        uses: anthropics/claude-code-action@b433f16b30d54063fd3bab6b12f46f3da00e41b6 # 2026-02-10
        env:
          # Force all HTTP(S) traffic through the Squid proxy
          HTTP_PROXY: http://localhost:3128
          HTTPS_PROXY: http://localhost:3128
          NO_PROXY: localhost,127.0.0.1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          # Pre-exchanged GitHub App token (skips action's internal OIDC flow)
          github_token: ${{ steps.oidc-exchange.outputs.app_token }}
          # Pre-installed Bun and Claude Code (skips action's internal installs)
          path_to_bun_executable: ${{ steps.setup-deps.outputs.bun_path }}
          path_to_claude_code_executable: ${{ steps.setup-claude.outputs.path }}
          plugin_marketplaces: "/tmp/skill-issue"
          plugins: |
            personal-skills@eni-skills
            base-config@eni-skills
          # Prompt: empty string for comments (action extracts text after @claude)
          prompt: ""
          claude_args: |
            --model opus
            --dangerously-skip-permissions
            --system-prompt "${{ env.CUSTOM_SYSTEM_PROMPT }}"

      # Revoke the GitHub App token after use (the action skips this when github_token is provided)
      - name: Revoke GitHub App token
        if: always() && steps.oidc-exchange.outputs.app_token != ''
        run: |
          curl -sf -X DELETE \
            -H "Authorization: Bearer $APP_TOKEN" \
            "${GITHUB_API_URL:-https://api.github.com}/installation/token" \
            || echo "Token revocation failed (may already be expired)"
        env:
          APP_TOKEN: ${{ steps.oidc-exchange.outputs.app_token }}
