name: claude-review

# Triggered by @claude mention in PR comments.
# The prompt is extracted as the text after "@claude" in the comment body.
#
# Security model:
#   - Only write/admin users can trigger (enforced by permission check on the App token)
#   - Network sandbox: Squid proxy (L7 domain allowlist) + iptables (L3 egress block)
#   - All dependencies pre-installed before lockdown
#
# Secrets:
#   - CLAUDE_CODE_OAUTH_TOKEN: Anthropic API auth (from `claude setup-token`)
#   - CLAUDE_ACCESS_TOKEN: PAT with 'repo' scope for cloning private repos

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]

permissions: {}

jobs:
  claude-review:
    name: claude-review/respond
    if: |
      contains(github.event.comment.body, '@claude') &&
      (github.event.issue.pull_request || github.event_name == 'pull_request_review_comment')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
      id-token: write
      actions: read
    steps:

      # ── Phase 1: Setup (full network) ──────────────────────────────────
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false
          fetch-depth: 0

      - name: Install uv
        uses: astral-sh/setup-uv@61cb8a9741eeb8a550a1b8544337180c0fc8476b

      - name: Clone private repositories
        run: gh repo clone enitrat/skill-issue /tmp/skill-issue
        env:
          GH_TOKEN: ${{ secrets.CLAUDE_ACCESS_TOKEN }}

      - name: Build custom system prompt
        id: custom_prompt
        run: |
          if [[ "$EVENT_NAME" == "pull_request" ]] || [[ -n "$ISSUE_PR_URL" ]]; then
            if [[ "$EVENT_NAME" == "pull_request" ]]; then
              PR_TITLE="$PR_TITLE_INPUT"
              PR_AUTHOR="$PR_AUTHOR_INPUT"
              PR_HEAD="$PR_HEAD_INPUT"
              PR_BASE="$PR_BASE_INPUT"
              PR_STATE="$PR_STATE_INPUT"
              PR_ADDITIONS="$PR_ADDITIONS_INPUT"
              PR_DELETIONS="$PR_DELETIONS_INPUT"
              PR_COMMITS="$PR_COMMITS_INPUT"
              PR_FILES="$PR_FILES_INPUT"
            else
              PR_NUMBER="$ISSUE_NUMBER_INPUT"
              PR_DATA=$(gh pr view "$PR_NUMBER" --json title,author,headRefName,baseRefName,state,additions,deletions,commits)
              PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
              PR_AUTHOR=$(echo "$PR_DATA" | jq -r '.author.login')
              PR_HEAD=$(echo "$PR_DATA" | jq -r '.headRefName')
              PR_BASE=$(echo "$PR_DATA" | jq -r '.baseRefName')
              PR_STATE=$(echo "$PR_DATA" | jq -r '.state')
              PR_ADDITIONS=$(echo "$PR_DATA" | jq -r '.additions')
              PR_DELETIONS=$(echo "$PR_DATA" | jq -r '.deletions')
              PR_COMMITS=$(echo "$PR_DATA" | jq -r '.commits | length')
              PR_FILES=$(gh pr view "$PR_NUMBER" --json files | jq '.files | length')
            fi

            FORMATTED_CONTEXT="PR Title: ${PR_TITLE}
          PR Author: ${PR_AUTHOR}
          PR Branch: ${PR_HEAD} -> ${PR_BASE}
          PR State: ${PR_STATE^^}
          PR Additions: ${PR_ADDITIONS}
          PR Deletions: ${PR_DELETIONS}
          Total Commits: ${PR_COMMITS}
          Changed Files: ${PR_FILES} files"
          else
            FORMATTED_CONTEXT="Issue Title: ${ISSUE_TITLE_INPUT}
          Issue Author: ${ISSUE_AUTHOR_INPUT}
          Issue State: ${ISSUE_STATE_INPUT^^}"
          fi

          SYSTEM_PROMPT="You are Claude, an AI assistant designed to help with GitHub issues and pull requests. Think carefully as you analyze the context and respond appropriately. Here's the context for your current task:

          <formatted_context>
          ${FORMATTED_CONTEXT}
          </formatted_context>"

          {
            echo "CUSTOM_SYSTEM_PROMPT<<EOF"
            echo "$SYSTEM_PROMPT"
            echo "EOF"
          } >> "$GITHUB_ENV"
        env:
          GH_TOKEN: ${{ secrets.CLAUDE_ACCESS_TOKEN }}
          EVENT_NAME: ${{ github.event_name }}
          ISSUE_PR_URL: ${{ github.event.issue.pull_request.url || '' }}
          PR_TITLE_INPUT: ${{ github.event.pull_request.title }}
          PR_AUTHOR_INPUT: ${{ github.event.pull_request.user.login }}
          PR_HEAD_INPUT: ${{ github.event.pull_request.head.ref }}
          PR_BASE_INPUT: ${{ github.event.pull_request.base.ref }}
          PR_STATE_INPUT: ${{ github.event.pull_request.state }}
          PR_ADDITIONS_INPUT: ${{ github.event.pull_request.additions }}
          PR_DELETIONS_INPUT: ${{ github.event.pull_request.deletions }}
          PR_COMMITS_INPUT: ${{ github.event.pull_request.commits }}
          PR_FILES_INPUT: ${{ github.event.pull_request.changed_files }}
          ISSUE_NUMBER_INPUT: ${{ github.event.issue.number }}
          ISSUE_TITLE_INPUT: ${{ github.event.issue.title }}
          ISSUE_AUTHOR_INPUT: ${{ github.event.issue.user.login }}
          ISSUE_STATE_INPUT: ${{ github.event.issue.state }}

      # ── Phase 2: Pre-install dependencies (before lockdown) ────────────

      # OIDC → Anthropic exchange → GitHub App token
      - name: Exchange OIDC for GitHub App token
        id: oidc-exchange
        run: |
          OIDC_TOKEN=$(curl -sf \
            -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=claude-code-github-action" | jq -r '.value')
          [ -n "$OIDC_TOKEN" ] && [ "$OIDC_TOKEN" != "null" ] || { echo "::error::OIDC token request failed"; exit 1; }

          APP_TOKEN=$(curl -sf -X POST \
            -H "Authorization: Bearer $OIDC_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"permissions":{"contents":"write","pull_requests":"write","issues":"write"}}' \
            "https://api.anthropic.com/api/github/github-app-token-exchange" | jq -r '.token')
          [ -n "$APP_TOKEN" ] && [ "$APP_TOKEN" != "null" ] || { echo "::error::Token exchange failed"; exit 1; }

          echo "::add-mask::$APP_TOKEN"
          echo "app_token=$APP_TOKEN" >> "$GITHUB_OUTPUT"

      # Post a tracking comment immediately so the user sees the job link
      - name: Post tracking comment
        id: tracking-comment
        run: |
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          ISSUE_NUMBER="${{ github.event.issue.number || github.event.pull_request.number }}"
          BODY="**Claude is working on @${{ github.actor }}'s request...** — [View run]($RUN_URL)"
          COMMENT_ID=$(gh api "repos/${{ github.repository }}/issues/${ISSUE_NUMBER}/comments" \
            -X POST -f body="$BODY" --jq '.id')
          echo "comment_id=$COMMENT_ID" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ steps.oidc-exchange.outputs.app_token }}

      # Claude Code CLI — native binary, no bun required
      - name: Install Claude Code (npm)
        id: setup-claude
        run: |
          npm install -g @anthropic-ai/claude-code@2.1.42
          echo "path=$(which claude)" >> "$GITHUB_OUTPUT"

      # ── Phase 3: Network sandbox ───────────────────────────────────────
      - name: Start Squid proxy
        run: |
          docker run -d --name sandbox-proxy -p 3128:3128 \
            -v "${{ github.workspace }}/.github/squid/sandbox-proxy-rules.conf:/etc/squid/conf.d/00-sandbox-proxy-rules.conf:ro" \
            ubuntu/squid

          # Wait for readiness (api.github.com returns 200 without auth, unlike api.anthropic.com)
          for i in $(seq 1 30); do
            curl -sf -x http://localhost:3128 -o /dev/null https://api.github.com 2>/dev/null && break
            [ "$i" -eq 30 ] && { echo "::error::Squid proxy failed to start"; docker logs sandbox-proxy; exit 1; }
            sleep 2
          done

          # Verify: allowed domain works, blocked domain is rejected
          HTTP_CODE=$(curl -s -x http://localhost:3128 -o /dev/null -w '%{http_code}' https://api.github.com)
          if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 400 ]; then
            echo "::error::Allowed domain returned $HTTP_CODE"; exit 1
          fi
          if curl -sf -x http://localhost:3128 -o /dev/null https://google.com 2>/dev/null; then
            echo "::error::Blocked domain reachable!"; exit 1
          fi

      - name: Lock down iptables
        run: |
          RUNNER_UID=$(id -u)

          # Resolve Squid container's IP dynamically to avoid allowing the entire 172.16/12 range
          SQUID_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' sandbox-proxy)
          if [ -z "$SQUID_IP" ]; then
            echo "::error::Could not determine Squid container IP"; exit 1
          fi
          echo "Squid IP: $SQUID_IP"

          # Allow established connections and loopback (covers local DNS via 127.0.0.53)
          sudo iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
          sudo iptables -A OUTPUT -o lo -j ACCEPT

          # Allow traffic to Squid container only (single host, port 3128)
          sudo iptables -A OUTPUT -d "$SQUID_IP" -p tcp --dport 3128 -j ACCEPT

          # Block new outbound TCP from runner UID — forces proxy use
          sudo iptables -A OUTPUT -m owner --uid-owner "$RUNNER_UID" -p tcp --syn -j REJECT --reject-with tcp-reset

          # Block UDP and ICMP from runner UID — prevents DNS tunneling and ICMP exfiltration
          sudo iptables -A OUTPUT -m owner --uid-owner "$RUNNER_UID" -p udp -j DROP
          sudo iptables -A OUTPUT -m owner --uid-owner "$RUNNER_UID" -p icmp -j DROP

          # Verify: direct blocked, proxy works
          if curl -sf --max-time 5 -o /dev/null https://google.com 2>/dev/null; then
            echo "::error::Direct connection not blocked!"; exit 1
          fi
          if ! curl -sf --max-time 10 -x http://localhost:3128 -o /dev/null https://api.github.com 2>/dev/null; then
            echo "::error::Proxy broken!"; exit 1
          fi

      # ── Phase 4: Run Claude Code (sandboxed) ───────────────────────────
      #
      # Runs claude directly (no action wrapper) to avoid MCP server processes
      # that block on stdin and keep the job alive after Claude finishes.
      # See: https://github.com/anthropics/claude-code-action/issues/865

      - name: Run Claude Code
        id: run-claude
        run: |
          # Install plugins from local marketplace (no network needed)
          claude plugin marketplace add /tmp/skill-issue
          claude plugin install personal-skills@eni-skills
          claude plugin install base-config@eni-skills

          # Extract prompt: everything after "@claude" in the comment
          PROMPT=$(echo "$COMMENT_BODY" | sed 's/.*@claude[[:space:]]*//')

          claude -p "$PROMPT" \
            --model opus \
            --dangerously-skip-permissions \
            --system-prompt "$CUSTOM_SYSTEM_PROMPT"
        env:
          GITHUB_TOKEN: ${{ steps.oidc-exchange.outputs.app_token }}
          GH_TOKEN: ${{ steps.oidc-exchange.outputs.app_token }}
          HTTP_PROXY: http://localhost:3128
          HTTPS_PROXY: http://localhost:3128
          NO_PROXY: localhost,127.0.0.1
          COMMENT_BODY: ${{ github.event.comment.body }}
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}

      # ── Cleanup ────────────────────────────────────────────────────────

      - name: Update tracking comment
        if: always() && steps.tracking-comment.outputs.comment_id != ''
        run: |
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          if [ "${{ steps.run-claude.outcome }}" = "success" ]; then
            BODY="**Claude finished @${{ github.actor }}'s task** — [View run]($RUN_URL)"
          else
            BODY="**Run finished with status: ${{ steps.run-claude.outcome }}** — [View run]($RUN_URL)"
          fi
          PAYLOAD=$(jq -n --arg body "$BODY" '{body: $body}')
          curl -sS -o /dev/null -w '%{http_code}\n' \
            -x http://localhost:3128 \
            -X PATCH \
            -H "Authorization: Bearer $APP_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            "https://api.github.com/repos/${{ github.repository }}/issues/comments/${{ steps.tracking-comment.outputs.comment_id }}"
        env:
          APP_TOKEN: ${{ steps.oidc-exchange.outputs.app_token }}

      - name: Revoke GitHub App token
        if: always() && steps.oidc-exchange.outputs.app_token != ''
        run: |
          HTTP_STATUS=$(curl -sS -o /dev/null -w '%{http_code}' -x "$HTTPS_PROXY" -X DELETE \
            -H "Authorization: Bearer $APP_TOKEN" \
            "https://api.github.com/installation/token")
          if [ "$HTTP_STATUS" -ne 204 ]; then
            echo "::warning::Token revocation failed (HTTP $HTTP_STATUS)"
          fi
        env:
          APP_TOKEN: ${{ steps.oidc-exchange.outputs.app_token }}
          HTTPS_PROXY: http://localhost:3128
